
\section{Background}\label{section:background}

\subsection{Information Retrieval (IR) and Search Engine}\label{section:IR}
``Information Retrieval (IR) is the activity of obtaining information resources relevant to an information need from a collection of information resources''~\cite{IR}. 
An information retrieval process begins when a user 
enters a query into the system. Queries are formal statements of information needs, for example search strings in web search engines. However, the 
submitted query may not give the satisfying results for the user. In this case, the process begins again. Figure~\ref{fig:retrieval_process} illustrates
search process. As information resources were not originally intended for access (Retrieval of unstructured data)[P. 7]~\cite{IRlecture}. 
it is impossible for a user query to uniquely identify a single object in the collection. Instead, several objects may match the query, 
with different degrees of relevancy. In IR field, there are various types of retrieval models used to compute the degree of relevancy. This will
be discussed in more details in section~\ref{section:retrieving}.

A search engine is an information retrieval system designed to help find information stored on a computer system~\cite{searchengine}. The search results are usually 
presented in a list and are commonly called hits. Search engines help to minimize the time required to find information and the amount of 
information which must be consulted~\cite{searchengine}. The special kind of search engine is 
web search engine. It is a software system that is designed to search for information on the World Wide Web~\cite{websearchengine}.

\begin{figure}
\centering
\includegraphics[scale=1]{./figures/retrieval_process.png}
\caption{Search Process} \label{fig:retrieval_process}
\end{figure}

\subsubsection{Brief Overview of Information Retrieval System Architecture}\label{section:IRarchitecture}
In IR systems, two main objectives have to be met~\cite{IRarchitecture} - first, the results must satisfy user - this means retrieving information to meet user's
information need, second, retrieving process must be fast. This section is devoted to a brief overiew of the architecture of IR systems which makes readers
understand how documents are retrieved and the data structure used in IR systems.To understand how retrieval process works, we must understand 
indexing process first. This process is done offline. There are 4 steps in indexing process and each process is performed sequentially~\cite{IRarchitecture}:
\begin{enumerate}
 \item Tokenisation
 \item Stopwords Removal
 \item Stemming
 \item Inverted Index Structure Creation
\end{enumerate}
Given a document containing Albert Einstein's quote about life,

\begin{quotation}
 \item There are only two ways to live your life. One is as though nothing is a miracle. The other is as though everything is a miracle.
\end{quotation}

it can be illustrated in a terms-frequency table.
\begin{figure}
\centering
\includegraphics[scale=0.5]{./figures/text.png}
\caption{Document} \label{fig:quote} 
\end{figure}

\begin{table}
\centering
\begin{tabular}{|c|c|}

\hline \textbf{Term} & \textbf{frequency} \\
\hline there & 1 \\
\hline are & 1 \\
\hline only & 1 \\ 
\hline two & 1 \\
\hline ways & 1 \\
\hline live & 1 \\
\hline your & 1 \\
\hline life & 1 \\
\hline to & 1 \\
\hline one & 1 \\
\hline is & 3 \\
\hline as & 2 \\
\hline though & 2 \\
\hline nothing & 1 \\
\hline a & 2 \\
\hline miracle & 2 \\
\hline the & 1 \\
\hline other & 1 \\
\hline everything & 1 \\  
\hline
\end{tabular}
\caption{Terms and Frequency} \label{table:termsandfrequency}
\end{table}

Table \ref{table:termsandfrequency} shows all the terms and frequency of each term in the document. It can be seen that there are some words in the 
document which occur too frequently. These words are not good discriminators. They are referred to as ``stopwords''. Stopwords include
articles, prepositions, and conjunctions etc.

\paragraph{Tokenisation}
is the process of breaking a stream of text into words called tokens(terms)~\cite{tokenization}. The stream of text will be used by other indexing process.

\paragraph{Stopwords Removal}
is the process of removing stopwords in order to reduce the size of the indexing structure~\cite[P. 15]{IRarchitecture}. This also results in efficient lookup.
Table \ref{table:stopwordsremoval} shows all the terms and frequency of each term after stopwords removal process.

\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline \textbf{Term} & \textbf{frequency} \\
\hline two & 1 \\
\hline ways & 1 \\
\hline live & 1 \\
\hline life & 1 \\
\hline one & 1 \\
\hline nothing & 1 \\
\hline miracle & 2 \\
\hline everything & 1 \\  
\hline
\end{tabular}
\caption{Terms and Frequency After Stopwords Removal} \label{table:stopwordsremoval}
\end{table}
%Now, the table representing the document has shorter size and contains only meaningful words.

\paragraph{Stemming} is the process of reducing all words obtained with the same root into a single root~\cite[P. 20]{IRarchitecture}. 
A stem is the portion of a word which is left after
the removal of its affixes(i.e. prefixes and suffixes). For example, connect is the stem for the variants connected, connecting, and connection.
This process makes the size of the data shorter. There are various stemming algorithms such as Porter Stemming, and Suffix-stripping algorithms.

\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline \textbf{Term} & \textbf{frequency} \\
\hline two & 1 \\
\hline way & 1 \\
\hline live & 1 \\
\hline life & 1 \\
\hline one & 1 \\
\hline nothing & 1 \\
\hline miracle & 2 \\
\hline everything & 1 \\  
\hline
\end{tabular}
\caption{Terms and Frequency After Stemming} \label{table:stemming}
\end{table}
After stemming, all terms in the table are in its root forms. If a document is large in size, this process can reduce the size of the data considerably. However, 
there is one drawback. That is, it prevents interpretation of word meanings. For instance, the root form of the term ``gravitation'' is ``gravity''. But
the meaning of ``gravitation'' is different from ``gravity''.

\begin{figure}
\centering
\includegraphics[scale=0.5]{./figures/invertedIndex.png}
\caption{Simple Inverted Index} \label{fig:invertedIndex} 
\end{figure}

\paragraph{Inverted Index Structure Creation} is the process that creates an index data structure storing a mapping from terms(keys) to its 
locations in a database file, or in a document or a set of documents(values)~\cite{invertedindex}. 
The purpose of this data structure is to allow a full text searches. In IR, a value in a key-value pair is called posting. There are a number of index
structures used in practice. However, the index used in most IR systems and in this project is inverted index.
Figure \ref{fig:invertedIndex} shows a simple inverted index. Given a query(a set of terms), it is now possible to efficiently search for
documents containing those terms. However, each posting may contain additional information or features
about a document such as the freqency of the term etc.

\subsubsection{Retrieval Models}\label{section:retrievalmodel}
Last section, basic indexing process was briefly explained. In this section, we will give a brief introduction to a few retrieval models including one
used in this project. In general, retrieval models can be categorised into 2 categories: probabilistic approach and non probabilistic approach.

\paragraph{Term Frequencyâ€“Inverse Document Frequency (tf-idf)} - 
tf-idf is a numerical statistic that is intended to reflect how important a word is to a document in a collection~\cite{tfidf}. As the name suggest, it consists
of 2 parts: term frequency (tf) and inverse document frequency (idf). Term frequency is the number of occurrences a term appears in a document.
Inverse document frequency (idf) is a measure of whether the term is common or rare across all documents~\cite{tfidf}.
This component is very important for instance if a query term appears in most of the documents in the corpus, it is not appropriate to give a 
document containing that term a high score because that term is not a very good discriminator. On the other hand, it is appropriate to give high scores to 
documents containing terms rarely apprear in the corpus.
The following is the formula of \textbf{tf-idf} weighting model:
\begin{equation}
W_{fk} = f_{fd}(log N/D_k)
\end{equation}
where $N$ is the number of documents in the collection, $f_{fd}$ is tf of ${k^{th}}$ keyword in document $d$ (term frequency),
and $D_k$ is the number of documents containing ${k^{th}}$ keyword. The $log N/D_k$ is the idf of the model.
This model is a non-probabiltic approach and one of the easiest models in IR.

\paragraph{BM25} - 
In addition to non-probabiltic approach,
BM25 and Language Model are very popular probabiltic retrieval models. We will briefly discuss these models. Why use probabilities? 
In section~\ref{section:IR}, we explained that IR deals with uncertain and unstructured information. In other words, we do not know specifically
what the documents are really about. As a consequence, a query does not uniquely identify a single object in the collection. Therefore, probability theory
seems to be the most natural way to quantify uncertainty~\cite[P. 7]{probModel}.

Let $x$ be a document in the collection, $R_{d\vec{q}}$ represent the \textit{relevance} of a document $d$ with respect to query $\vec{q}$ 
and $NR_{d\vec{q}}$ represent \textit{non-relevance} of a document $d$ with respect to query $\vec{q}$.  We will use $R$ and $NR$ to represent the former and the latter
for brevity. The aim is to find $P(R|x)$ - the probability that a retrieved document x is relevant. 
\begin{equation}
P(R|x) = \frac{P(x|R)P(R)}{P(x)}
\end{equation}
\begin{equation}
P(NR|x) = \frac{P(x|NR)P(NR)}{P(x)}
\end{equation}


The above two equations are derived from Bayes theorem.
Note that $P(R|x) + P(NR|x) = 1$. If $P(R|x) > P(NR|x)$, then a document $x$ is relevant. This tells us when to stop ranking. To move further, we have
to understand \textbf{Binary Independence Model} (BIM). In BIM, binary means boolean (0 or 1) and documents are represented as binary vectors of terms:
\[\vec{x} = (x_t,...,x_n), 1 <= t <= n\] where $x_t$ is 1 if and only if the term $x_t$ is present in document $\vec{x}$, 0 otherwise. Independence means terms occur
in documents independently. Althought this assumption is far from correct, it often gives satisfactory results in practice.
To derive a ranking for query terms, we do the following:
\begin{equation}
\frac{P(R|x)}{P(NR|x)} = \frac{\frac{P(x|R)P(R)}{P(x)}}{\frac{P(x|NR)P(NR)}{P(x)}}
\end{equation}

Since we are only ranking documents, there is thus no need for us to estimate $P(R)$ and $P(NR)$. We now end up with 
\begin{equation}
\frac{P(R|x)}{P(NR|x)} = \frac{P(x|R)}{P(x|NR)}
\end{equation}


It is at this point that
we make the \textbf{Naive Bayes conditional independence assumption}~\cite[P. 261]{introToIR} that the presence
or absence of a word in a document is independent of the presence or absence
of any other word (given the query):
\begin{equation} \label{eq:prod}
\frac{P(R|x)}{P(NR|x)} = \prod_{t:x_t=1}^M\frac{P(x_t = 1|R)}{P(x_t = 1|NR)} \prod_{t:x_t=0}^M\frac{P(x_t = 0|R)}{P(x_t = 0|NR)}
\end{equation}
where ${P(x_t = 1|R)}$ is a probability of a term $x_t$ appearing in a document relevant to a query, ${P(x_t = 1|NR)}$ is a probability of a term $x_t$ appearing in a document irrelevant
to a query, $P(x_t = 0|R)$ is a probability of a term $x_t$ not appearing in a document relevant to a query and 
$P(x_t = 0|NR)$ is a probability of a term $x_t$ not appearing in a document irrelevant to a query. 


For brevity, let $p_t$ = ${P(x_t = 1|R)}$ be the probability of a term appearing in a document relevant to the query, and $u_t$ = $P(x_t = 1|NR)$.
These quantities can be visualised in table~\ref{table:bim}.

\begin{table}
 \centering
\begin{tabular}{|c|c|c|c|}
\hline  & \textbf{Document} & \textbf{Relevant (R)} & \textbf{Non-relevant (NR)} \\
\hline Term present & $x_t = 1$ & $p_t$ & $u_t$\\
\hline Term absent & $x_t = 0$ & $1 - p_t$ & $1 - u_t$ \\ 
\hline
\end{tabular}
\label{table:bim}
\end{table}

From equation~\ref{eq:prod}, we now have the following:
\begin{equation}
\frac{P(R|x)}{P(NR|x)} = \prod_{t:x_t=1}^M\frac{p_t}{u_t} (\prod_{t:x_t=1}^M\frac{1-u_t}{1-p_t}\prod_{t:x_t=1}^M\frac{1-p_t}{1-u_t})
  \prod_{t:x_t=0}^M\frac{1-p_t}{1-u_t}
\end{equation}

Let us make an additional simplifying assumption that terms not occurring in the query are equally likely to occur in relevant and nonrelevant documents: 
that is, if $q_t$ = 0 then $p_t$ = $u_t$. We now end up with the equation as follows:
\begin{equation}~\label{eq:RVS}
\frac{P(R|x)}{P(NR|x)} = \prod_{t:x_t=1}^M\frac{p_t(1-u_t)}{u_t(1-p_t)}
\end{equation}

From equation~\ref{eq:RVS}, we can apply logarithm to avoid zero product and the resulting quantity used for ranking is
called the Retrieval Status Value (RSV) as shown in equation~\ref{eq:logRVS}.
\begin{equation}~\label{eq:logRVS}
\frac{P(R|x)}{P(NR|x)} = \sum_{t:x_t=1}^M log \frac{p_t(1-u_t)}{u_t(1-p_t)}
\end{equation}

\begin{table}
 \centering
\begin{tabular}{|cc|c|c|c|c|}
\hline  & \textbf{Document} & \textbf{Relevant (R)} & \textbf{Non-relevant (NR)} & \textbf{Total} \\
\hline Term present & $x_t = 1$ & $r_t$ & $u_t - r_t$ & $n_t$\\
 Term absent & $x_t = 0$ & $R - r_t$ & $N - n_t - R + r_t$ & $N - n_t$ \\ 
\hline & Total & $R$ & $N - R$ & $N$ \\
\hline
\end{tabular}
\label{table:bimTable}
\end{table}

From Binary Independence Model theory, we can estimate $p_t$ and $u_t$ based on quantities from table~\ref{bimTable} as follows:
\[
 p_t \approx \frac{r_t}{R},  u_t \approx \frac{n - r_t}{N - R}
\]

Substituting $p_t$ and $u_t$ to equation~\ref{eq:logRVS}, we have
\begin{equation}~\label{eq:newlogRVS}
\sum_{t \in \vec{q}} log(c_t) = \sum_{t:x_t=1}^M log \frac{r_t/(R - r_t)}{(n_t - r_t)/(N - n_t - R + r_t)}
\end{equation}

From equation~\ref{eq:newlogRVS}, we can formulate BM25 formula:
\begin{equation}~\label{eq:BM25}
\sum_{t \in \vec{q}}^M log \frac{r_t/(R - r_t)}{(n_t - r_t)/(N - n_t - R + r_t)} \frac{(k_1 + 1)tf_{td}}{K + tf_{td}} \frac{k_2 + 1)tf_{tq}}{k_2 + tf_{tq}}
\end{equation}
where $K$ = $k_t((1 - b) + b\frac{dl}{avdl})$, $tf_tq$ and $tf_td$ are the frequency of term $t$ in the query $\vec{q}$ and document $d$ respectively,
and $b$, $dl$ and $avdl$ are paraameters set empirically. The proof of BM25 is beyond the scope of the project.

\paragraph{PL2} PL2 is a model from the divergence from randomness framework, based on a poisson distribution~\cite{craig}. This project uses PL2 weight model to 
calculate score. This model is also probabilistic approach. The proof and explanation are out of the scope of the project.


\subsubsection{Retrieval Process in Information Retrieval}\label{section:retrieving}
\begin{figure}
\centering
\includegraphics[scale=0.3]{./figures/retrieval.png}
\caption{Retrieval Process} \label{fig:retrieval} 
\end{figure}
Section~\ref{section:IRarchitecture} and Section~\ref{section:retrievalmodel} explained basic indexing process and a few retrieval models respectively.
In this section, we will see how documents are retrieved. Figure ~\ref{fig:retrieval} shows
retrieval process of IR system. In IR, there are 2 phases in general:
online and offline phases. The offline phase is the phase that all documents in the corpus are indexed and all features are extracted 
(section~\ref{section:IRarchitecture}). 

%Then for each document, features are extracted. The feature extracting
%process is not mandatory and application dependent. One most extracted feature is the frequency of the terms occured in a document.
%This feature can be applied to both tf-idf and BM25 explained in section~\ref{section:retrievalmodel}.
%Subsequently, inverted index is built.

On the other hand, online phase begins after a user submits a query into the system. After that, tokenisation, stopwords removal and stemming processes 
are performed as same as the offline phase.
Features can also be extracted from query terms as well. At this point, it comes to the process of matching and assigning scores to documents.
This process can make use of one of the retrieval models explained in section~\ref{section:retrievalmodel}. In this project, PL2 weighting model and voting
technique which will be explained in section~\ref{section:voting} are used to compute score.
Once scores have been assigned to relevant documents, the system ranks all documents in order of decreasing scores and 
show to the user. Figure~\ref{fig:retrieval} gives a graphical representation of retrieval process.

\subsubsection{Evaluation}\label{sec:evaluation}
This section is devoted to backgrounds of evaluation of IR systems. It is very important as it is a background for Evaluation Section. 
Since IR is research-based, understanding how evaluation is carried out will give a background for the readers to determine whether 
this project is achieved or not. In IR, there are 3 main reasons for evaluating IR systems~\cite[P. 3]{eval}: 
\begin{enumerate}
 \item Economic reasons: If people are going to buy the technology, they want to know how effective it is.
 \item Scientific reasons: Researchers want to know if progress is being made. So they need a measure for progress. 
	This can show that their IR system is better or worse than someone else's.
 \item Verification: If an IR system is built, it is necessary to verify the performance.
\end{enumerate}

To measure information retrieval effectiveness in the standard way, a test collection is required and it consists of 3 things~\cite{evalweb}:
\begin{enumerate}
 \item A document collection.
 \item A test suite of information needs, expressible as queries.
 \item A set of relevance judgments, standardly a binary assessment of either relevant or nonrelevant for each query-document pair.
\end{enumerate}

The standard approach to information retrieval system evaluation revolves around the notion of relevant and nonrelevant documents. With respect 
to a user information need, a document in the test collection is given a binary classification as either relevant or nonrelevant~\cite{evalweb}. However,
this can be extended by using numbers as an indicator of the degree of relevancy. For example, documents labelled 2 is more relevant than documents
labelled 1, or documents labelled 0 is not relevant. There are a number of test collection stardards. In this project, Text Retrieval Conference (TREC)
is used since it is widely used in the field of IR.

%\paragraph{Precision and Recall}
\subsubsection{Precision and Recall}
The function of an IR system is to~\cite[P. 10]{eval}:
\begin{itemize}
 \item retrieve all \textit{relevant documents} measured by \textbf{Recall}
 \item retrieve \textit{no non-relevant documents} measured by \textbf{Precision}
\end{itemize}

Precision (P) is the fraction of retrieved documents that are relevant 
\begin{center}
 \raisebox{-\totalheight}{\includegraphics[scale=0.5]{./figures/precision.png}}
\end{center}

Recall (R) is the fraction of relevant documents that are retrieved 
\begin{center}
\raisebox{-\totalheight}{\includegraphics[scale=0.5]{./figures/recall.png}}
\end{center}

If a system has high precision but low recall, the system returns relevant documents but misses many useful ones.
If a system has low precision but high recall, the system returns most relevant documents but includes lots of junks.
Therefore, the ideal is to have both high precision and recall. To give a good example, consider Figure ~\ref{fig:pr_example}, since
overall IR system A (blue) has higher precision than IR system B (red), system A is better than system B.

\begin{figure}
\centering
\includegraphics[scale=0.5]{./figures/pr_example.png}
\caption{Precision-Recall Graph} \label{fig:pr_example} 
\end{figure}

However, in certain cases, precisions of system A may be higher values than system B in some recall points or vice versa. Therefore,
Mean Average Precision (MAP), Normalized Discounted Cumulative Gain (NDCG) and Mean Reciprocal Rank (MRR) are used to address this problem.
Each of them has different behaviours of evaluation.

\paragraph{Mean Average Precision (MAP)}
MAP for a set of queries is the mean of the average precision scores for each query~\cite{IR}. The equation below is
a formula for MAP.
\begin{center}
\raisebox{-\totalheight}{\includegraphics[scale=0.5]{./figures/map.png}}
\end{center}
where Q is the number of queries.

\paragraph{Mean Reciprocal Rank (MRR)}
MRR is a statistic measure for evaluating a list of possible responses to a set of queries, ordered by 
probability of correctness~\cite{mrr}. The equation below is a formula for MRR.
\begin{center}
\raisebox{-\totalheight}{\includegraphics[scale=0.5]{./figures/mrr.png}}
\end{center}
where $rank_i$ is the position of the correct result and $|Q|$ is the number of queries.

\paragraph{Normalized Discounted Cumulative Gain (NDCG or nDCG)}
To understand NDCG, first of all, we have to understand \textbf{Discounted Cumulative Gain (DCG)}. 
The premise of DCG is that highly relevant documents appearing in lower position in a search result list should be penalized as the graded relevance value is 
reduced logarithmically proportional to the position of the result.~\cite{ndcg}. The discounted CG accumulated at a particular rank position
$p$ is defined as:

\begin{center}
\raisebox{-\totalheight}{\includegraphics[scale=0.5]{./figures/dcg.png}}
\end{center}

From DCG, we can formulate NDCG as follows:
\begin{center}
\raisebox{-\totalheight}{\includegraphics[scale=0.5]{./figures/ndcg.png}}
\end{center}
where $IDCG_p$ is the maximum possible (ideal) DCG for a given set of queries, documents, and relevances.


\subsection{Learning to Rank (LETOR)}\label{sec:letor}
Learning to rank or machine-learned ranking (MLR) is a type of supervised or semi-supervised machine learning problem in which the goal is 
to automatically construct a ranking model from training data~\cite{letor}.
Employing learning to rank techniques to learn the ranking function is viewed as
a promising approach to information retrieval~\cite{letor}. In particular, many learning to rank aproaches attempt to learn a combination of features
(called the learned model)~\cite[P. 3]{learningmodel}. The resulting learned model is applied to a vector of features for each document, to determine the final scores for 
producing the final ranking of documents for a query~\cite[P. 3]{learningmodel}. In learning to rank, a feature is a binary or numberical indicator 
representing the quality of a document, or its relation to the query~\cite[P. 4]{learningmodel}. This will be discussed in more details in later section.

\subsubsection*{Query Dependent Feature}\label{section:querydependent}
Figure~\ref{fig:retrieval_process} shows a simple search process in IR. After a user submits a query into an IR system. The system ranks the results 
with respect to the query and returns a result set to the user. It can be clearly seen that the results obtained with respect to the query depends on the 
query the user submitted. In other words, document A can have 2 different degrees of relevancy if a user changes a query.
In learning to rank, this is called query dependent feature.

\subsubsection*{Query Independent Feature}\label{section:queryindependent}
In contrast to Query Dependent Feature, a feature that does not depend on a user query is called query independent feature. This feature is fixed for each
document. For now, it is better to not dig into great details about this because this will be focused in later section.

\subsubsection*{Obtaining and Deploying a Learned Model} \label{sec:learnedmodel}
The general steps for obtaining a learned model using a learning to rank technique are the following~\cite[P. 4]{learningmodel}:

\begin{quote}
  \item \textit{1. Top k Retrieval: For a set of training queries, generate a sample of k documents using an initial retrieval approach.}
  \item \textit{2. Feature Extraction: For each document in the sample, extract a vector of feature values.}
  \item \textit{3. Learning: Learn a model by applying a learning to rank technique. Each technique deploys a different loss function to estimate the goodness of
	various combination of features. Documents are labelled according to available relevance assessments.}

Once a learned model has been obtained from the above learning steps, it can be deployed within a search engine as follows~\cite[P. 4]{learningmodel}

 \item \textit{4. Top k Retrieval: For an unseen test query, a sample of k documents is generated in the same manner as step (1).}
 \item \textit{5. Feature Extraction: As in step (2), a vector of feature values is extracted for each document in the sample. The set of features should be exactly
	the same as for (2).}
 \item \textit{6. Learned Model Application: The final ranking of documents for the query is obtained by applying the learned model on every document in the sample,
	and sorting by descending predicted score.}
\end{quote}

\begin{figure}
\centering
\includegraphics[scale=0.7]{./figures/letor.png}
\caption{An architecture of a machine-learned IR system from \protect\url{http://en.wikipedia.org/wiki/Learning_to_rank}} \label{fig:letor} 
\end{figure}
Figure~\ref{fig:letor} illustrates an architecture of a machine-learned IR system. The architecture will be discussed in more details in Design and 
Implementation Section.

\subsection{Tools}

\subsubsection{Terrier}\label{section:terrier}
Every IR system requires programs that handle indexing, retrieving, ranking, etc. To build everything from scratch, it would be impossible within
the 1 year duration. However, there are a number of search engine platforms that deal with IR functionalities effectively.
Terrier~\cite{terrier} was chosen because it is a highly flexible, efficient, and effective open source search engine.
It is a comprehensive, and flexible platform for research and experimentation in text retrieval. Research can easily be 
carried out on standard TREC collection~\cite{trec}. 
Using Terrier, this project can easily extend from the existing search engine as it used Terrier as a search engine platform and it is written in Java
which is the same programming language used in this project.

\paragraph{Terrier Indexing}
\begin{figure}
\centering
\includegraphics[scale=0.4]{./figures/terrierindexing.png}
\caption{Indexing Architecture of Terrier from \protect\url{http://terrier.org/docs/v3.5/basicComponents.html}} \label{fig:terrierindexing} 
\end{figure}

Figure~\ref{fig:terrierindexing} gives an overview of the interaction of the main components involved in the indexing process of Terrier.

\begin{quotation}
 \item 1. A corpus will be represented in the form of a \textbf{Collection} object. Raw text data will be represented in the form of a \textbf{Document} object. 
 Document implementations usually are provided with an instance of a \textbf{Tokeniser} class that breaks pieces of text into single indexing tokens.
 \item 2. The indexer is responsible for managing the indexing process. It iterates through the documents of the collection and sends each found 
 term through a \textbf{TermPipeline} component.
 \item 3. A TermPipeline can transform terms or remove terms that should not be indexed. An example for a TermPipeline chain is 
 termpipelines=Stopwords,PorterStemmer, which removes terms from the document using the \textbf{Stopwords} object, and then applies Porter's Stemming algorithm 
 for English to the terms.
 \item 4. Once terms have been processed through the TermPipeline, they are aggregated and the following data structures are created by their corresponding 
 DocumentBuilders: DirectIndex, DocumentIndex, Lexicon, and InvertedIndex.
 \item 5. For single-pass indexing, the structures are written in a different order. Inverted file postings are built in memory, and committed to 'runs' 
 when memory is exhausted. Once the collection had been indexed, all runs are merged to form the inverted index and the lexicon.
\end{quotation}

\subsubsection{RankLib}\label{section:rankLib}
RankLib~\cite{ranklib} is an open source library of learning to rank algorithms. It also implements many retrieval metrics as well as provides many ways to carry out evaluation.
Currently eight popular algorithms have been implemented:
\begin{itemize}
 \item MART (Multiple Additive Regression Trees, a.k.a. Gradient boosted regression tree)
 \item RankNet
 \item RankBoost
 \item AdaRank
 \item Coordinate Ascent
 \item LambdaMART
 \item ListNet
 \item Random Forests
\end{itemize}

This library was chosen because it is easy to use, written in Java which can be easily combined with this system as it is also developed using Java, and
it implements 8 different learning to rank algorithms which makes it possible for users to try different algorithms.
However, AdaRank and Coordinate Ascent were only used in the project because other algorithms are too complex and not part of the scope of this project.

\subsubsection{trec\_eval}\label{sec:treceval}
trec\_eval is the standard tool used by the TREC community~\cite{trec} for evaluating a retrieval run, given the results file and a
standard set of judged results. trec\_eval was chosen because the data used in this project uses TREC format. 
It is easy to use and written in C which makes the tool efficient. To use trec\_eval, 2 files are required: qrels and result file in TREC format.
\textit{qrels} is a file that stores relevant results for queries stored in a queries file~\cite{qrels}. It has the following format~\cite{qrelsformat}:
\begin{quotation}
 \textit{TOPIC ITERATION DOCUMENT\# RELEVANCY}
\end{quotation}
where \textit{TOPIC} is the query, \textit{ITERATION} is the feedback iteration (almost always zero and not used),
\textit{DOCUMENT\#} is the official document number that corresponds to the "docno" field in the documents (in this project, expert's id), and
\textit{RELEVANCY} is a number indicating a degree of relevancy. In this project, 3 numbers: 0, 1, and 2 indicating non-relevant, relevant and perfectly
relevant respectively, are used. The result file is the file that contains the following~\cite{resultfileformat}:
\begin{quotation}
 \textit{TOPIC ITERATION DOCUMENT\# RANK SIM RUN\_ID}
\end{quotation}
where \textit{RANK} is the position of the corresponding document\# in a ranking, \textit{SIM} is a float value indicating a score and \textit{RUN\_ID}
is a string which gets printed out with the output.



\subsection{Expert Search}
In section~\ref{sec:expertsearch}, we discussed about the definition of Expert Search. This section will give 5 scenarios proposed by Yimam-Seid \& Kobsa
why expert search is needed~\cite[P. 387]{expertsearch}.
\begin{quotation}
  \item \textit{1. Access to non-documented information - e.g. in an organisation where not all relevant information is documented.}
  \item \textit{2. Specification need - the user is unable to formulate a plan to solve a problem, and resorts to seeking experts to assist them in formulating a plan.}
  \item \textit{3. Leveraging on another's expertise (group efficiency) - e.g. finding a piece of information that a relevant expert would know/find with
  less effort than the seeker.}
  \item \textit{4. Interpretation need - e.g. deriving the implications of, or understanding, a piece of information.}
  \item \textit{5. Socialisation need - the user may prefer that the human dimension be involved, as opposed to interacting with documents and computers.}
\end{quotation}

\subsubsection{Presenting Query Results}\label{sec:presentingQueryResult}
Figure~\ref{fig:retrieval_process} illustrates the process of search. From this figure, the process will start again if a user is not satisfied with 
the results. In this section, the focus is on how to convince user that a query result is good. Suppose a user who is currently studying software engineering
would like to know ``how to normalize database tables'', first of all, he needs to interpret his information need into a query which is ``database normalization''.
He then types his query into his preferred search engine. After he submits the query, the search engine gives him a list of results ranked by the degree
of relevancy. The question is how does he determine which result is what he is looking for?. Well, he could assume that the ranking provided by the search 
engine is correct. That is, the first result is what he is looking for. However, this is not always the case. He then explores each result and sees if 
it is the right one. But without exploring each result, could he be able to determine that which result is likely to satisfy his information need?
Perhaps, there has to be some evidence to convince him by just looking at the result. The followings are evidence he could take into account~\cite{craig}: 
\begin{itemize}
 \item URL
 \item Photo
 \item Author
 \item keywords of the article name
\end{itemize}
If a result in response to a query have all or some of these evidence, it has more credits than ones with no evidence at all. 
\begin{figure}
\centering
\includegraphics[scale=0.3]{./figures/query.png}
\caption{Sample Query} \label{fig:query}
\end{figure}
Figure \ref{fig:query} shows the results of the query ``database normalization''. It is obvious that from the top 4 results, all of the article names
include the keywords a user submitted, and the third result does not have query keywords included in the URL. Among all of which, the second result has more 
evidence than others. It has an author's name, a photo of an author that other results do not.

\subsubsection{Voting Technique}\label{section:voting}
In section ~\ref{section:retrieving}, we very briefly talked about weighting model. In other words, how documents are assigned scores using tf-idf. In this section,
it aims to give an overview of voting technique used in this project. To understand this section, readers must understand what data fusion technique is. 
``Data fustion techniques also known as metasearch techniques, are used to combine separate rankings of documents into a single ranking,
with the aim of improving over the performance of any constituent ranking''~\cite[P. 388]{expertsearch}. Within the context of this project, 
expert search is seen as a voting problem. The profile of each candidate is a set of documents associated to him to represent their expertise.
When each document associated to a candidate's profile get retrieved by the IR system, implicit vote for that candidate occurs~\cite[P. 389]{expertsearch}.
Data fusion technique is then used to combine the ranking with respect to the query and the implicit vote. In expert search task, it shows that 
``improving the quality of the underlying document representation can significantly improve the retrieval performance of the data fusion techniques 
on an expert search task''~\cite[P. 387]{expertsearch}. To give a simple example how data fusion technique works, take a look at this example

Let R(Q) be the set of documents retrieved for query Q, and the set of documents belonging to the profile candidate C be denoted profile(C). In expert
search, we need to find a ranking of candidates, given R(Q). Consider the simple example in Tables ~\ref{table:ranking} and ~\ref{table:profiles}.
The ranking of documents with respect to the query has retrieved documents \{D1, D2, D3, D4\}. Using the candidate profiles, candidate C1 has accumulated
3 votes, C2 2 votes, C3 2 votes and C4 no votes. If all votes are counted equally, and each document in a candidate's profile is equally weighted, a possible
ranking of candidates to this query could be \{C1, C2, C3\}. However, in this project, the technique used is expCombMNZ and the formular is as follows

\begin{table}
\centering
\begin{tabular}{|c|c|c|}
\hline \textbf{Rank} & \textbf{Docs} & \textbf{Scores}\\
\hline 1 & D1 & 5.4 \\
\hline 2 & D2 & 4.2\\
\hline 3 & D3 & 3.9 \\
\hline 4 & D4 & 2.0 \\  
\hline
\end{tabular}
\caption{R(Q)} \label{table:ranking}
\end{table}
\quad
\begin{table}
\centering
\begin{tabular}{|c|l|}
\hline \textbf{Profiles} & \textbf{Docs}\\
\hline C1 & D3, D4, D2 \\
\hline C2 & D1, D2 \\
\hline C3 & D3, D2 \\
\hline C4 & D5, D6 \\  
\hline
\end{tabular}
\caption{Profiles} \label{table:profiles}
\end{table}

\[
candScore(C,Q) = |R(Q) \cap profile(C)| \sum_{d \in R(Q) \cap profile(C)} exp(score_d)
\]
where $|R(Q) \cap profile(C)|$ is the number of documents from the profile of candidate C that are in the ranking R(Q).














